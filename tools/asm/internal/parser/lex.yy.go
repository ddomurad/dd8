// Code generated by golex. DO NOT EDIT.

package parser

import (
	"fmt"
)

var (
	buf       string
	curSymbol byte
)

const EOF = 0

func (l *lexer) Lex(lval *yySymType) int {
	c := curSymbol

yystate0:

	buf = buf[:0]

	goto yystart1

yystate1:
	c = l.getNext()
yystart1:
	switch {
	default:
		goto yyabort
	case c == '0':
		goto yystate4
	case c == ';':
		goto yystate10
	case c == '\t' || c == '\n' || c == '\r' || c == ' ':
		goto yystate3
	case c == '\x00':
		goto yystate2
	case c == '{' || c == '}':
		goto yystate14
	case c >= '1' && c <= '9':
		goto yystate5
	case c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z':
		goto yystate13
	}

yystate2:
	c = l.getNext()
	goto yyrule8

yystate3:
	c = l.getNext()
	switch {
	default:
		goto yyrule1
	case c == '\t' || c == '\n' || c == '\r' || c == ' ':
		goto yystate3
	}

yystate4:
	c = l.getNext()
	switch {
	default:
		goto yyrule4
	case c == 'b':
		goto yystate6
	case c == 'x':
		goto yystate8
	case c >= '0' && c <= '9':
		goto yystate5
	}

yystate5:
	c = l.getNext()
	switch {
	default:
		goto yyrule4
	case c >= '0' && c <= '9':
		goto yystate5
	}

yystate6:
	c = l.getNext()
	switch {
	default:
		goto yyabort
	case c == '0' || c == '1':
		goto yystate7
	}

yystate7:
	c = l.getNext()
	switch {
	default:
		goto yyrule6
	case c == '0' || c == '1':
		goto yystate7
	}

yystate8:
	c = l.getNext()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate9
	}

yystate9:
	c = l.getNext()
	switch {
	default:
		goto yyrule5
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate9
	}

yystate10:
	c = l.getNext()
	switch {
	default:
		goto yyrule7
	case c == '\x00' || c == '\n':
		goto yystate11
	case c >= '\x01' && c <= '\t' || c >= '\v' && c <= 'ÿ':
		goto yystate12
	}

yystate11:
	goto yyrule2

yystate12:
	c = l.getNext()
	switch {
	default:
		goto yystate11 // c == '\x00' || c == '\n'
	case c >= '\x01' && c <= '\t' || c >= '\v' && c <= 'ÿ':
		goto yystate12
	}

yystate13:
	c = l.getNext()
	switch {
	default:
		goto yyrule3
	case c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z':
		goto yystate13
	}

yystate14:
	c = l.getNext()
	goto yyrule7

yyrule1: // [ \t\n\r]+
	{
		// Ignore whitespace
		goto yystate0
	}
yyrule2: // ;.*$

	goto yystate0
yyrule3: // {OP_CODE}
	{
		lval.String = buf
		return OP_CODE
		goto yystate0
	}
yyrule4: // {DEC_NUM}
	{
		lval.Number = mustParseNumber(buf, 10)
		return DEC_NUM
		goto yystate0
	}
yyrule5: // {HEX_NUM}
	{
		lval.Number = mustParseNumber(buf[2:len(buf)], 16)
		return HEX_NUM
		goto yystate0
	}
yyrule6: // {BIN_NUM}
	{
		lval.Number = mustParseNumber(buf[2:len(buf)], 2)
		return HEX_NUM
		goto yystate0
	}
yyrule7: // {SYMBOLS}
	{
		return int(buf[0])
	}
yyrule8: // \0
	if true { // avoid go vet determining the below panic will not be reached
		return EOF
	}
	panic("unreachable")

yyabort: // no lexem recognized
	// silence unused label errors for build and satisfy go vet reachability analysis
	{
		if false {
			goto yyabort
		}
		if false {
			goto yystate0
		}
		if false {
			goto yystate1
		}
	}

	panic(fmt.Sprintf("Unrecognized symbol: '%c' at %s", l.input[0], l.codePointer.String()))
}
